using System.Collections.Immutable;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace TailwindVariants.SourceGenerators;

[Generator]
public class TvDescriptorPropertyExtractor : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		// Find all field declarations with TvDescriptor type
		var tvDescriptorFields = context.SyntaxProvider
			.CreateSyntaxProvider(
				predicate: static (node, _) => IsTvDescriptorField(node),
				transform: static (ctx, _) => GetTvDescriptorInfo(ctx))
			.Where(static info => info is not null);

		context.RegisterSourceOutput(tvDescriptorFields, GeneratePropertyExtensions);
	}

	private static bool IsTvDescriptorField(SyntaxNode node)
	{
		return node is FieldDeclarationSyntax field &&
			   field.Declaration.Type is GenericNameSyntax generic &&
			   generic.Identifier.Text == "TvDescriptor";
	}

	private static TvDescriptorInfo? GetTvDescriptorInfo(GeneratorSyntaxContext context)
	{
		var fieldDeclaration = (FieldDeclarationSyntax)context.Node;
		var variable = fieldDeclaration.Declaration.Variables.FirstOrDefault();

		if (variable?.Initializer?.Value is not ObjectCreationExpressionSyntax creation)
			return null;

		var genericType = fieldDeclaration.Declaration.Type as GenericNameSyntax;
		if (genericType?.TypeArgumentList.Arguments.Count != 2)
			return null;

		var componentType = genericType.TypeArgumentList.Arguments[0].ToString();
		var slotsType = genericType.TypeArgumentList.Arguments[1].ToString();

		// Find the variants argument
		var variantsArg = creation.ArgumentList?.Arguments
			.FirstOrDefault(arg => arg.NameColon?.Name.Identifier.Text == "variants");

		if (variantsArg?.Expression is not ObjectCreationExpressionSyntax variantsInit)
			return null;

		var properties = ExtractPropertyNames(variantsInit, componentType, slotsType, context);

		return new TvDescriptorInfo(
			FieldName: variable.Identifier.Text,
			ComponentType: componentType,
			SlotsType: slotsType,
			Properties: properties
		);
	}

	private static ImmutableArray<string> ExtractPropertyNames(
		ObjectCreationExpressionSyntax variantsInit,
		string componentType,
		string slotsType,
		GeneratorSyntaxContext context)
	{
		var properties = ImmutableArray.CreateBuilder<string>();

		if (variantsInit.Initializer is null)
			return properties.ToImmutable();

		foreach (var expression in variantsInit.Initializer.Expressions)
		{
			if (expression is not AssignmentExpressionSyntax assignment)
				continue;

			// The key should be an indexer with a lambda: [b => b.Property]
			if (assignment.Left is not ImplicitElementAccessSyntax elementAccess)
				continue;

			var lambdaArg = elementAccess.ArgumentList.Arguments.FirstOrDefault();
			if (lambdaArg?.Expression is not SimpleLambdaExpressionSyntax lambda)
				continue;

			// Check if this lambda returns a component property, not a slot property
			if (lambda.Body is MemberAccessExpressionSyntax memberAccess)
			{
				var parameterName = lambda.Parameter.Identifier.Text;

				// Ensure the member access is on the lambda parameter (e.g., "b" in "b => b.Property")
				if (memberAccess.Expression is IdentifierNameSyntax identifier &&
					identifier.Identifier.Text == parameterName)
				{
					var propertyName = memberAccess.Name.Identifier.Text;

					// Verify this is a component property, not a slot property
					if (IsComponentProperty(propertyName, componentType, slotsType, context))
					{
						properties.Add(propertyName);
					}
				}
			}
		}

		return properties.ToImmutable();
	}

	private static bool IsComponentProperty(
		string propertyName,
		string componentType,
		string slotsType,
		GeneratorSyntaxContext context)
	{
		// Get the semantic model to resolve types
		var componentSymbol = context.SemanticModel.Compilation
			.GetTypeByMetadataName(componentType);

		var slotsSymbol = context.SemanticModel.Compilation
			.GetTypeByMetadataName(slotsType);

		// Check if property exists in component type
		var componentHasProperty = componentSymbol?.GetMembers(propertyName)
			.Any(m => m.Kind == SymbolKind.Property) ?? false;

		// Check if property exists in slots type
		var slotsHasProperty = slotsSymbol?.GetMembers(propertyName)
			.Any(m => m.Kind == SymbolKind.Property) ?? false;

		// It's a component property if it exists in component but not in slots
		return componentHasProperty && !slotsHasProperty;
	}

	private static void GeneratePropertyExtensions(
		SourceProductionContext context,
		TvDescriptorInfo? info)
	{
		if (info is null)
			return;

		var source = $$"""
            // <auto-generated/>
            #nullable enable
            
            namespace TailwindVariants.Generated
            {
                public static class {{info.ComponentType.Replace(".", "_")}}_Properties
                {
                    public static readonly string[] VariantProperties = new[]
                    {
            {{string.Join(",\n            ", info.Properties.Select(p => $"            \"{p}\""))}}
                    };
                }
            }
            """;

		context.AddSource(
			$"{info.ComponentType.Replace(".", "_")}_Properties.g.cs",
			source);
	}

	private record TvDescriptorInfo(
		string FieldName,
		string ComponentType,
		string SlotsType,
		ImmutableArray<string> Properties);
}
