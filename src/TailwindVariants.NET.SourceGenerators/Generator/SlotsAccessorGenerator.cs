using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Text;

namespace TailwindVariants.NET.SourceGenerator;

/// <summary>
/// Generates source code to provide strongly-typed accessors and extension methods for slot-based mapping types at
/// compile time.
/// </summary>
/// <remarks>This generator scans the compilation for types that use slot mapping patterns and produces helper
/// classes, enums, and extension methods to simplify and optimize access to slot properties. The generated code enables
/// type-safe access to slot names and values, reducing reliance on string-based lookups and improving maintainability.
/// This generator is intended for use with types following the SlotMap&lt;T&gt; convention and is typically invoked
/// automatically by the build process when included in a project.</remarks>
[Generator]
public class SlotsAccessorGenerator : IIncrementalGenerator
{
    ///<inheritdoc />
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // All type declarations
        var candidates = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is TypeDeclarationSyntax,
                static (ctx, _) => ctx.SemanticModel.GetDeclaredSymbol(ctx.Node) as INamedTypeSymbol)
            .Where(static s => s is not null)
            .Collect();

        context.RegisterSourceOutput(candidates, static (spc, types) => Execute(types!, spc));
    }

    private static void Execute(ImmutableArray<INamedTypeSymbol> types, SourceProductionContext spc)
    {
        foreach (var type in types)
        {
            if (!ImplementsISlots(type))
                continue;

            GenerateForSlotsType(type, spc);
        }
    }

    private static void GenerateForSlotsType(INamedTypeSymbol slotsType, SourceProductionContext spc)
    {
        // Must be partial
        if (!slotsType.DeclaringSyntaxReferences.Any(sr =>
                sr.GetSyntax() is TypeDeclarationSyntax tds &&
                tds.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword))))
        {
            var diag = Diagnostic.Create(
                DiagnosticHelper.MustBePartial,
                slotsType.Locations.FirstOrDefault(),
                slotsType.Name);
            spc.ReportDiagnostic(diag);
            return;
        }

        // Collect public instance properties
        var properties = slotsType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public)
            .ToArray();

        if (properties.Length == 0)
        {
            var diag = Diagnostic.Create(
                DiagnosticHelper.NoPropertiesDescriptor,
                Location.None,
                slotsType.ToDisplayString());

            spc.ReportDiagnostic(diag);
            return;
        }

        // Deterministic order: source order if available, fallback to name order
        var ordered = properties.OrderBy(p => p.Locations.FirstOrDefault()?.SourceSpan.Start ?? int.MaxValue)
                                .ThenBy(p => p.Name, StringComparer.Ordinal)
                                .ToArray();

        var slotsTypeName = slotsType.ContainingType?.Name ?? slotsType.Name.Replace("Slots", string.Empty);

        // Build names
        var enumName = SymbolHelper.MakeSafeIdentifier(slotsTypeName + "SlotsTypes");
        var extClassName = SymbolHelper.MakeSafeIdentifier(slotsTypeName + "SlotsExtensions");
        var namesClass = SymbolHelper.MakeSafeIdentifier(slotsTypeName + "SlotsNames");

        var namespaceName = slotsType.ContainingNamespace?.ToDisplayString() ?? string.Empty;

        // Build array of slot property names (string literals)
        var slotNames = ordered.Select(p => p.Name).ToArray();

        // Full type display for the slots generic type argument
        var slotsTypeFull = slotsType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", "");
        var slotMapTypeFull = $"SlotsMap<{slotsTypeFull}>";

        // Prepare unique filename
        var fq = slotsType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var filename = SymbolHelper.MakeSafeFileName($"{fq}.g.cs");

        var sb = new Indenter();

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using TailwindVariants.NET;");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        // ISlots

        var hierarchy = GetSlotsHieararhy(slotsType);
        var mods = GetSlotsModifiers(slotsType);

        // Open nested containers
        foreach (var container in hierarchy.Take(hierarchy.Length - 1))
        {
            sb.AppendLine($"partial class {container}");
            sb.AppendLine("{");
            sb.Indent();
        }

        sb.AppendLine($"{mods} {slotsType.Name}");
        sb.AppendLine("{");
        sb.Indent();

        sb.AppendLine("public IEnumerable<(string Slot, string Value)> EnumerateOverrides()");
        sb.AppendLine("{");
        sb.Indent();

        foreach (var p in properties)
        {
            sb.AppendLine($"if (!string.IsNullOrWhiteSpace({p.Name}))");
            sb.Indent();
            sb.AppendLine($"yield return (nameof({p.Name}), {p.Name}!);");
            sb.Dedent();
        }

        sb.Dedent();
        sb.AppendLine("}");

        sb.Dedent();
        sb.AppendLine("}");

        // Close nested containers
        foreach (var _ in hierarchy.Take(hierarchy.Length - 1))
        {
            sb.Dedent();
            sb.AppendLine("}");
        }

        // Enum
        sb.AppendLine($"public enum {enumName}");
        sb.AppendLine("{");
        sb.Indent();
        for (int i = 0; i < slotNames.Length; i++)
        {
            var nm = SymbolHelper.MakeSafeIdentifier(slotNames[i]);
            sb.AppendLine($"{nm} = {i},");
        }
        sb.Dedent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Names helper
        sb.AppendLine($"public static class {namesClass}");
        sb.AppendLine("{");
        sb.Indent();
        sb.AppendLine($"private static readonly string[] _names = new[] {{ {string.Join(", ", slotNames.Select(n => "\"" + n + "\""))} }};");
        sb.AppendLine();
        sb.AppendLine($"public static string NameOf({enumName} key) => _names[(int)key];");
        sb.AppendLine($"public static IReadOnlyList<string> AllNames => _names;");
        sb.Dedent();
        sb.AppendLine("}");
        sb.AppendLine();

        // Extension methods on SlotMap<SlotsType>
        sb.AppendLine($"public static class {extClassName}");
        sb.AppendLine("{");
        sb.Indent();
        sb.AppendLine($"public static string? Get(this {slotMapTypeFull} slots, {enumName} key) => slots.Map[{namesClass}.NameOf(key)];");
        sb.Dedent();
        sb.AppendLine();

        // Per-property sugar
        sb.Indent();
        foreach (var p in ordered)
        {
            var propName = p.Name;
            var safe = SymbolHelper.MakeSafeIdentifier(propName);
            sb.AppendLine($"public static string? Get{safe}(this {slotMapTypeFull} slots) => slots.Get({enumName}.{safe});");
            sb.AppendLine();
        }
        sb.Dedent();

        sb.AppendLine("}");

        spc.AddSource(filename, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string[] GetSlotsHieararhy(INamedTypeSymbol slotsType)
    {
        var typeStack = new Stack<string>();
        var current = slotsType;
        while (current != null)
        {
            typeStack.Push(current.Name);
            current = current.ContainingType;
        }
        return [.. typeStack];
    }

    private static string GetSlotsModifiers(INamedTypeSymbol slotsType)
    {
        var mods = slotsType.DeclaredAccessibility switch
        {
            Accessibility.Public => "public ",
            Accessibility.Internal => "internal ",
            _ => ""
        };
        if (slotsType.IsSealed) mods += "sealed ";
        else if (slotsType.IsAbstract) mods += "abstract ";

        mods += "partial class";
        return mods;
    }
    private static bool ImplementsISlots(INamedTypeSymbol type)
        => type.AllInterfaces.Any(i => i.ToDisplayString() == "TailwindVariants.NET.ISlots");
}