namespace TailwindVariants.NET.SourceGenerators;

public partial class TvOptionsGenerator
{
	private static void WriteExtensions(Indenter sb, OptionsInfo options)
	{
		sb.AppendMultiline($$"""
        /// <summary>
        /// Provides extension methods for strongly-typed access to <see cref="{{options.SlotsClassName}}"/> 
        /// via a <see cref="SlotsMap{T}"/>.
        /// </summary>
        """);

		sb.AppendLine($"public static class {options.ExtClassName}");
		sb.AppendLine("{");
		sb.Indent();

		sb.AppendMultiline($$"""
        /// <summary>
        /// Gets the value of the slot identified by the specified <see cref="{{options.EnumClassName}}"/> key.
        /// </summary>
        /// <param name="slots">The <see cref="SlotsMap{T}"/> instance containing slot values.</param>
        /// <param name="key">The enum key representing the slot to retrieve.</param>
        /// <returns>The value of the slot, or <c>null</c> if not set.</returns>
        """);

		sb.AppendLine($"public static string? Get(this {options.SlotsTypeName} slots, {options.EnumClassName} key, {options.OptionsClassName}? options = null)");
		sb.Indent();
		sb.AppendLine($" => slots[{options.NamesClassName}.NameOf(key)](options);");
		sb.Dedent();

		foreach (var property in options.SlotsProperties)
		{
			var safe = SymbolHelper.MakeSafeIdentifier(property);
			sb.AppendLine();
			sb.AppendMultiline($$"""
			/// <summary>
			/// Gets the value of the <c>{{property}}</c> slot.
			/// </summary>
			/// <param name="slots">The <see cref="SlotsMap{T}"/> instance containing slot values.</param>
			/// <returns>The value of the <c>{{property}}</c> slot, or <c>null</c> if not set.</returns>
			""");

			sb.AppendLine($"public static string? Get{safe}(this {options.SlotsTypeName} slots, {options.OptionsClassName}? options = null)");
			sb.Indent();
			sb.AppendLine($" => slots.Get({options.EnumClassName}.{safe}, options);");
			sb.Dedent();
		}

		sb.Dedent();
		sb.AppendLine("}");
	}

	private static void WriteOptions(Indenter sb, OptionsInfo options)
	{
		var inheritance = options.Inheritance;

		sb.AppendLine($"public partial class {options.OptionsClassName} :{(inheritance.IsDirectImplementation ? "" : $" {inheritance.BaseClassName},")} TailwindVariants.NET.IOptions");
		sb.AppendLine("{");
		sb.Indent();

		if (inheritance.IsDirectImplementation)
		{
			sb.AppendLine("public string? Class { get; set; }");
		}

		foreach (var (name, type) in options.VariantsProperties)
		{
			sb.AppendLine();
			var safe = SymbolHelper.MakeSafeIdentifier(name);
			sb.AppendLine($"public {type} {safe} {{ get; set; }}");
		}

		sb.Dedent();
		sb.AppendLine("}");
		sb.AppendLine();
	}


	private static void WritePragmaClosing(Indenter sb)
	{
		sb.AppendLine();
		sb.AppendLine("#pragma warning restore CS1591");
		sb.AppendLine("#pragma warning restore CS8618");
	}

	private static void WritePreamble(Indenter sb, OptionsInfo options)
	{
		sb.AppendLine("// <auto-generated />");
		sb.AppendLine();
		sb.AppendLine("#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member");
		sb.AppendLine("#pragma warning disable CS8618 // Non-nullable field is uninitialized");
		sb.AppendLine();
		sb.AppendLine("using TailwindVariants.NET;");
		sb.AppendLine("using System;");
		sb.AppendLine("using System.Collections.Generic;");
		sb.AppendLine();
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		if (!string.IsNullOrEmpty(options.NamespaceName) && options.NamespaceName != "<global namespace>")
		{
			sb.AppendLine($"namespace {options.NamespaceName};");
			sb.AppendLine();
		}
	}
}
